<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bin Packing - Desafío de Contenedores</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #F0F4F8; color: #1a1a1a; }
        .item-box, .item-in-bin { transition: all 0.2s ease-in-out; cursor: grab; }
        .item-box:active, .item-in-bin:active { cursor: grabbing; transform: scale(1.05); box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); z-index: 10; }
        .bin-container-visual { height: 200px; border: 5px solid #9FB3C8; border-top: none; border-radius: 0 0 10px 10px; position: relative; transition: all 0.2s ease-in-out; background-color: #D9E2EC; }
        .bin-items-wrapper { position: absolute; bottom: 0; left: 0; right: 0; display: flex; flex-direction: column-reverse; align-items: center; }
        .item-in-bin { width: 80%; text-align: center; font-weight: bold; color: white; border-radius: 4px; margin-bottom: 2px; overflow: hidden; border: 2px solid rgba(0,0,0,0.2); }
        .drag-over { background-color: #C7D5E5; border-color: #2563eb; }
        .bin-full { border-color: #ef4444 !important; }
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.75); display: flex; justify-content: center; align-items: center; z-index: 50; }
        .btn-type-active { background-color: #0284c7; color: white; }
        .btn-type-inactive { background-color: #e5e7eb; color: #4b5563; }
        .btn-difficulty-active { background-color: #dc2626; color: white; }
        .btn-difficulty-inactive { background-color: #e5e7eb; color: #4b5563; }
    </style>
</head>

<body class="bg-slate-50 text-slate-800">
    <div class="container mx-auto p-4 md:p-8 relative">
         <div class="absolute top-4 right-4 flex flex-col sm:flex-row items-end sm:items-center gap-2 sm:gap-4 z-10">
           <a href="../pasarela/buymeacoffee.html" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-2 bg-yellow-400 text-gray-900 font-bold py-2 px-3 sm:px-4 rounded-lg shadow-sm transition-colors duration-300 hover:bg-yellow-500 text-sm sm:text-base">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" sm:width="20" sm:height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M1 12.5a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13a.5.5 0 0 1-.5-.5M2 4v6h10V4zm11.5 0a.5.5 0 0 0-.5.5v5a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-5a.5.5 0 0 0-.5-.5zM1 3.5a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13a.5.5 0 0 1-.5-.5m10.854-1.354a.5.5 0 0 0-.708 0L9 3.293 7.854 2.146a.5.5 0 1 0-.708.708L8.293 4 7.146 5.146a.5.5 0 1 0 .708.708L9 4.707l1.146 1.147a.5.5 0 0 0 .708-.708L9.707 4l1.147-1.146a.5.5 0 0 0 0-.708"/></svg>
                <span class="hidden sm:inline">Invítame un café</span>
                <span class="sm:hidden">Café</span>
            </a>
            <a href="../index.html" class="bg-white hover:bg-slate-100 text-slate-600 font-semibold py-2 px-3 sm:px-4 border border-slate-200 rounded-lg shadow-sm flex items-center transition-colors text-sm sm:text-base">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-5 sm:w-5 mr-1 sm:mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" /></svg>
                Inicio
            </a>
        </div>

        <header class="text-center mb-8 pt-16">
            <h1 class="text-2xl sm:text-3xl lg:text-4xl font-bold text-slate-900">Desafío de contenedores: optimiza el espacio</h1>
            <p class="text-sm sm:text-base lg:text-lg text-slate-600 mt-2">Arrastra los objetos a los contenedores. ¡Usa la menor cantidad posible!</p>
        </header>

        <!-- Panel de Instrucciones y Explicación -->
        <div class="my-8 bg-white rounded-xl shadow-md p-6">
            <button id="toggleInstructions" class="w-full flex items-center justify-between text-2xl font-bold mb-4 text-blue-600 hover:text-blue-700 transition-colors">
                <span>¿Cómo funciona?</span>
                <svg id="instructionsChevron" class="w-6 h-6 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
            <div id="instructionsContent" class="grid md:grid-cols-2 gap-6 text-slate-600 hidden">
                <div>
                    <h3 class="text-lg font-semibold mb-2">Instrucciones de uso</h3>
                    <ol class="list-decimal list-inside space-y-2">
                        <li><b>Ajusta el número de objetos</b> y la capacidad de los contenedores.</li>
                        <li>Elige si los contenedores tendrán capacidades iguales (<b>Homogéneo</b>) o diferentes (<b>Heterogéneo</b>).</li>
                        <li>Selecciona una <b>estrategia de dificultad</b> para generar objetos desafiantes.</li>
                        <li><b>Arrastra todos los objetos</b> disponibles hacia los contenedores.</li>
                        <li>Puedes mover objetos entre contenedores o devolverlos a la zona de disponibles.</li>
                        <li>Cuando termines, presiona <b>"Solución con algoritmo"</b> para comparar tu resultado.</li>
                    </ol>
                </div>
                <div>
                    <h3 class="text-lg font-semibold mb-2">Estrategias de dificultad</h3>
                    <p>
                        <b>Muchos objetos pequeños:</b> Alta proporción de objetos pequeños que requieren combinación precisa para llenar contenedores sin desperdicio.<br><br>
                        <b>Objetos grandes:</b> Mayoría de objetos grandes que son difíciles de combinar eficientemente.<br><br>
                        <b>Mezcla extrema:</b> Combinación de tamaños muy diferentes que requiere estrategia sofisticada.<br><br>
                        <b>Ajuste perfecto:</b> Objetos diseñados para maximizar la utilización de cada contenedor.
                    </p>
                </div>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <div class="lg:col-span-1 self-start lg:sticky lg:top-8 space-y-8">
                <div class="bg-white p-6 rounded-xl shadow-md">
                    <h2 class="text-2xl font-bold mb-4">Controles</h2>
                    <div class="space-y-4 mb-6">
                        <div>
                            <label for="num-items-input" class="font-semibold text-slate-600">Número de objetos:</label>
                            <input type="number" id="num-items-input" value="12" min="5" max="50" class="w-full mt-1 p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                        </div>
                        <div>
                            <label id="bin-capacity-label" for="bin-capacity-input" class="font-semibold text-slate-600">Capacidad máxima:</label>
                            <input type="number" id="bin-capacity-input" value="100" min="20" max="500" class="w-full mt-1 p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                        </div>
                        <div>
                            <label class="font-semibold text-slate-600">Tipo de contenedor:</label>
                            <div class="grid grid-cols-2 gap-2 mt-1">
                                <button id="type-homo" class="p-2 rounded-lg font-bold">Homogéneo</button>
                                <button id="type-hetero" class="p-2 rounded-lg font-bold">Heterogéneo</button>
                            </div>
                        </div>
                        <div>
                            <label class="font-semibold text-slate-600">Estrategia de dificultad:</label>
                            <div class="grid grid-cols-3 gap-1 mt-1">
                                <button id="difficulty-random" class="p-1 rounded-lg font-bold btn-difficulty-active text-xs">Aleatoria</button>
                                <button id="difficulty-small-items" class="p-1 rounded-lg font-bold btn-difficulty-inactive text-xs">Muchos objetos pequeños</button>
                                <button id="difficulty-large-items" class="p-1 rounded-lg font-bold btn-difficulty-inactive text-xs">Objetos grandes</button>
                                <button id="difficulty-mixed" class="p-1 rounded-lg font-bold btn-difficulty-inactive text-xs">Mezcla extrema</button>
                                <button id="difficulty-tight-fit" class="p-1 rounded-lg font-bold btn-difficulty-inactive text-xs">Ajuste perfecto</button>
                            </div>
                        </div>
                    </div>
                    <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4">
                        <button id="reset-button" class="w-full bg-blue-600 text-white font-bold py-3 px-4 sm:px-6 rounded-lg hover:bg-blue-700 text-sm sm:text-base">Generar objetos</button>
                        <button id="solve-button" class="w-full bg-teal-600 text-white font-bold py-3 px-4 sm:px-6 rounded-lg hover:bg-teal-700 disabled:bg-slate-400 disabled:cursor-not-allowed text-sm sm:text-base">Solución con algoritmo</button>
                    </div>
                    <p id="loading-text" class="mt-4 text-slate-500 hidden text-center">Calculando...</p>
                </div>

                <div class="bg-white p-6 rounded-xl shadow-md">
                    <h2 class="text-2xl font-bold mb-4">Estadísticas de la Instancia</h2>
                    <div id="instance-stats" class="space-y-2 text-sm text-slate-600">
                        <div>Total de objetos: <span id="total-items" class="font-semibold">-</span></div>
                        <div>Capacidad del contenedor: <span id="bin-capacity" class="font-semibold">-</span></div>
                        <div>Objetos pequeños (≤25%): <span id="small-items" class="font-semibold">-</span></div>
                        <div>Objetos medianos (25-75%): <span id="medium-items" class="font-semibold">-</span></div>
                        <div>Objetos grandes (>75%): <span id="large-items" class="font-semibold">-</span></div>
                        <div>Utilización promedio: <span id="avg-utilization" class="font-semibold">-</span></div>
                        <div class="mt-3 p-2 bg-slate-100 rounded text-xs">
                            <strong>¿Por qué es difícil?</strong>
                            <div id="difficulty-explanation" class="mt-1">Selecciona una estrategia para ver la explicación.</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-2">
                <div class="bg-white p-6 rounded-xl shadow-md mb-8">
                    <h2 class="text-2xl font-bold mb-4">Objetos disponibles</h2>
                    <div id="items-container" class="min-h-[100px] p-4 bg-slate-100 rounded-lg grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-4">
                    </div>
                </div>

                <div class="bg-white p-6 rounded-xl shadow-md">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-bold">Contenedores</h2>
                        <div id="comparison-controls" class="hidden flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2">
                            <button id="view-user-solution" class="bg-slate-500 text-white font-bold py-2 px-3 rounded-lg hover:bg-slate-600 text-xs sm:text-sm">Ver tu solución</button>
                            <button id="view-ga-solution" class="bg-teal-500 text-white font-bold py-2 px-3 rounded-lg hover:bg-teal-600 text-xs sm:text-sm">Ver solución del algoritmo</button>
                        </div>
                    </div>
                    <div id="bins-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-x-4 gap-y-10">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Results Modal -->
    <div id="results-modal" class="modal-overlay hidden">
        <div class="bg-white rounded-xl shadow-2xl p-8 max-w-4xl w-full mx-4 transform transition-all duration-300 scale-95 opacity-0" id="modal-content">
            <h2 class="text-3xl font-bold text-center mb-4">Resultados</h2>
            <div id="winner-message" class="text-center text-2xl font-bold my-4 p-4 rounded-lg"></div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 text-center">
                <div class="bg-slate-100 p-6 rounded-lg">
                    <h3 class="text-xl font-bold mb-3">Tu solución</h3>
                    <p class="text-lg">Contenedores usados: <span id="user-bins-used" class="font-bold text-blue-600"></span></p>
                    <p class="text-sm mt-1">Objetos: <span id="user-items-packed"></span></p>
                </div>
                <div class="bg-teal-100 border-2 border-teal-500 p-6 rounded-lg">
                    <h3 class="text-xl font-bold mb-3">Solución del algoritmo</h3>
                    <p class="text-lg">Contenedores usados: <span id="ga-bins-used" class="font-bold text-blue-600"></span></p>
                    <p class="text-sm mt-1">Objetos: <span id="ga-items-packed"></span></p>
                </div>
            </div>
            <p id="ga-time" class="text-center text-slate-500 mt-4"></p>
            <div id="modal-footer-buttons" class="mt-8 text-center space-x-4">
                <button id="retry-ga-button" class="bg-orange-500 text-white font-bold py-2 px-8 rounded-lg hover:bg-orange-600 hidden">Reintentar solución</button>
                <button id="close-modal-button" class="bg-gray-600 text-white font-bold py-2 px-8 rounded-lg hover:bg-gray-700">Cerrar</button>
            </div>
        </div>
    </div>

    <footer id="contact" class="bg-[#333333] text-white mt-12">
        <div class="container mx-auto px-6 py-10">
            <div class="text-center">
                <p class="text-gray-300 mb-2">Si tienes alguna pregunta o te gustaría colaborar, no dudes en escribirme.</p>
                <a href="../contacto.html" class="text-[#80CBC4] text-lg hover:underline">Contacto</a>
                <p class="text-gray-500 mt-8 text-sm">&copy; 2025 Jonás Velasco. Todos los derechos reservados.</p>
            </div>
        </div>
    </footer>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const dom = {
            itemsContainer: document.getElementById('items-container'),
            binsContainer: document.getElementById('bins-container'),
            numItemsInput: document.getElementById('num-items-input'),
            binCapacityInput: document.getElementById('bin-capacity-input'),
            binCapacityLabel: document.getElementById('bin-capacity-label'),
            typeHomoButton: document.getElementById('type-homo'),
            typeHeteroButton: document.getElementById('type-hetero'),
            solveButton: document.getElementById('solve-button'),
            resetButton: document.getElementById('reset-button'),
            loadingText: document.getElementById('loading-text'),
            resultsModal: document.getElementById('results-modal'),
            modalContent: document.getElementById('modal-content'),
            winnerMessage: document.getElementById('winner-message'),
            userBinsUsed: document.getElementById('user-bins-used'),
            gaBinsUsed: document.getElementById('ga-bins-used'),
            userItemsPacked: document.getElementById('user-items-packed'),
            gaItemsPacked: document.getElementById('ga-items-packed'),
            gaTime: document.getElementById('ga-time'),
            comparisonControls: document.getElementById('comparison-controls'),
            closeModalButton: document.getElementById('close-modal-button'),
            retryGaButton: document.getElementById('retry-ga-button'),
            difficultyRandom: document.getElementById('difficulty-random'),
            difficultySmallItems: document.getElementById('difficulty-small-items'),
            difficultyLargeItems: document.getElementById('difficulty-large-items'),
            difficultyMixed: document.getElementById('difficulty-mixed'),
            difficultyTightFit: document.getElementById('difficulty-tight-fit'),
            totalItems: document.getElementById('total-items'),
            binCapacity: document.getElementById('bin-capacity'),
            smallItems: document.getElementById('small-items'),
            mediumItems: document.getElementById('medium-items'),
            largeItems: document.getElementById('large-items'),
            avgUtilization: document.getElementById('avg-utilization'),
            difficultyExplanation: document.getElementById('difficulty-explanation'),
            toggleInstructions: document.getElementById('toggleInstructions'),
            instructionsContent: document.getElementById('instructionsContent'),
            instructionsChevron: document.getElementById('instructionsChevron'),
        };

        const state = {
            items: [],
            binCapacities: [],
            isHeterogeneous: false,
            difficultyStrategy: 'random',
            draggedItemId: null,
            draggedItemOrigin: null,
            userAssignments: new Map(),
            gaAssignments: new Map(),
            currentAssignments: new Map(),
        };

        const GA_CONFIG = { populationSize: 100, generations: 100, mutationRate: 0.1, crossoverRate: 0.8, tournamentSize: 5 };
        const ITEM_COLORS = ['#3B82F6', '#10B981', '#F59E0B', '#8B5CF6', '#EF4444', '#EC4899'];

        function generateState() {
                // 1. Define tus valores mínimo y máximo
            const MIN_VALUE = 10;
            const MAX_VALUE = 100;

            state.items = [];
            state.binCapacities = [];
            state.userAssignments.clear();
            state.gaAssignments.clear();
            const numItems = parseInt(dom.numItemsInput.value, 10);
            const maxCapacity = parseInt(dom.binCapacityInput.value, 10);

            // 3. Valida y ajusta el número de ítems
            if (numItems < MIN_VALUE || numItems > MAX_VALUE) {
                alert(`El valor debe estar entre ${MIN_VALUE} y ${MAX_VALUE}. Se ajustará automáticamente.`);
                // "Sujeta" el valor para que no sea menor que MIN_VALUE ni mayor que MAX_VALUE
                numItems = Math.max(MIN_VALUE, Math.min(numItems, MAX_VALUE));
                dom.numItemsInput.value = numItems; // Actualiza el campo en la página
            }

            // Generar ítems según la estrategia de dificultad
            state.items = generateItemsByStrategy(numItems, maxCapacity);

            // Generar capacidades de contenedores
            for (let i = 0; i < numItems; i++) {
                if (state.isHeterogeneous) {
                    const minHetCapacity = Math.floor(maxCapacity * 0.6);
                    const cap = Math.floor(Math.random() * (maxCapacity - minHetCapacity + 1)) + minHetCapacity;
                    state.binCapacities.push(cap);
                } else {
                    state.binCapacities.push(maxCapacity);
                }
            }
            state.currentAssignments = state.userAssignments;
        }

        function generateItemsByStrategy(numItems, maxCapacity) {
            const items = [];
            
            switch (state.difficultyStrategy) {
                case 'small-items':
                    // Estrategia: Alta proporción de ítems pequeños (≤ 1/4 de la capacidad)
                    // Esto es difícil porque requiere combinación precisa para llenar contenedores
                    for (let i = 0; i < numItems; i++) {
                        let size;
                        if (Math.random() < 0.8) { // 80% ítems pequeños
                            const min = Math.floor(maxCapacity * 0.05); // 5% de capacidad
                            const max = Math.floor(maxCapacity * 0.25); // 25% de capacidad
                            size = Math.floor(Math.random() * (max - min + 1)) + min;
                        } else { // 20% ítems medianos
                            const min = Math.floor(maxCapacity * 0.3);
                            const max = Math.floor(maxCapacity * 0.6);
                            size = Math.floor(Math.random() * (max - min + 1)) + min;
                        }
                        items.push({ 
                            id: `item-${i}`, 
                            size: Math.max(1, size), 
                            color: ITEM_COLORS[i % ITEM_COLORS.length] 
                        });
                    }
                    break;

                case 'large-items':
                    // Estrategia: Ítems grandes que son difíciles de combinar
                    for (let i = 0; i < numItems; i++) {
                        let size;
                        if (Math.random() < 0.7) { // 70% ítems grandes
                            const min = Math.floor(maxCapacity * 0.6);
                            const max = Math.floor(maxCapacity * 0.95);
                            size = Math.floor(Math.random() * (max - min + 1)) + min;
                        } else { // 30% ítems medianos
                            const min = Math.floor(maxCapacity * 0.3);
                            const max = Math.floor(maxCapacity * 0.55);
                            size = Math.floor(Math.random() * (max - min + 1)) + min;
                        }
                        items.push({ 
                            id: `item-${i}`, 
                            size: Math.max(1, size), 
                            color: ITEM_COLORS[i % ITEM_COLORS.length] 
                        });
                    }
                    break;

                case 'mixed':
                    // Estrategia: Mezcla extrema de tamaños muy diferentes
                    for (let i = 0; i < numItems; i++) {
                        let size;
                        const rand = Math.random();
                        if (rand < 0.4) { // 40% ítems muy pequeños
                            const min = Math.floor(maxCapacity * 0.02);
                            const max = Math.floor(maxCapacity * 0.15);
                            size = Math.floor(Math.random() * (max - min + 1)) + min;
                        } else if (rand < 0.7) { // 30% ítems medianos
                            const min = Math.floor(maxCapacity * 0.4);
                            const max = Math.floor(maxCapacity * 0.7);
                            size = Math.floor(Math.random() * (max - min + 1)) + min;
                        } else { // 30% ítems muy grandes
                            const min = Math.floor(maxCapacity * 0.75);
                            const max = Math.floor(maxCapacity * 0.98);
                            size = Math.floor(Math.random() * (max - min + 1)) + min;
                        }
                        items.push({ 
                            id: `item-${i}`, 
                            size: Math.max(1, size), 
                            color: ITEM_COLORS[i % ITEM_COLORS.length] 
                        });
                    }
                    break;

                case 'tight-fit':
                    // Estrategia: Ítems que requieren ajuste perfecto
                    // Genera ítems que se ajusten bien a la capacidad del contenedor
                    const targetBins = Math.ceil(numItems * 0.7); // Usar ~70% de capacidad total
                    const totalCapacity = maxCapacity * targetBins;
                    let remainingCapacity = totalCapacity;
                    
                    for (let i = 0; i < numItems - 1; i++) {
                        let size;
                        if (remainingCapacity > maxCapacity) {
                            // Generar ítems que se ajusten bien juntos
                            const min = Math.floor(maxCapacity * 0.1);
                            const max = Math.min(Math.floor(maxCapacity * 0.4), remainingCapacity - (numItems - i - 1));
                            size = Math.floor(Math.random() * (max - min + 1)) + min;
                        } else {
                            // Últimos ítems: usar el espacio restante
                            size = Math.max(1, Math.floor(remainingCapacity / (numItems - i)));
                        }
                        items.push({ 
                            id: `item-${i}`, 
                            size: Math.max(1, size), 
                            color: ITEM_COLORS[i % ITEM_COLORS.length] 
                        });
                        remainingCapacity -= size;
                    }
                    // Último ítem: crear un objeto desafiante que requiera ajuste perfecto
                    let lastItemSize;
                    if (remainingCapacity > maxCapacity) {
                        // Si queda mucho espacio, crear un objeto que requiera combinación específica
                        lastItemSize = Math.floor(maxCapacity * 0.6) + Math.floor(Math.random() * Math.floor(maxCapacity * 0.2));
                    } else if (remainingCapacity > maxCapacity * 0.5) {
                        // Si queda espacio moderado, usar la mayor parte pero no todo
                        lastItemSize = Math.floor(remainingCapacity * 0.8);
                    } else {
                        // Si queda poco espacio, usar todo lo disponible
                        lastItemSize = remainingCapacity;
                    }
                    
                    // Asegurar que no exceda la capacidad y sea al menos 1
                    lastItemSize = Math.max(1, Math.min(lastItemSize, maxCapacity));
                    
                    items.push({ 
                        id: `item-${numItems - 1}`, 
                        size: lastItemSize, 
                        color: ITEM_COLORS[(numItems - 1) % ITEM_COLORS.length] 
                    });
                    break;

                default: // 'random'
                    // Estrategia original: distribución aleatoria
                    for (let i = 0; i < numItems; i++) {
                        let size;
                        if (Math.random() < 0.7) { // 70% chance for a medium-large item
                            const min = Math.floor(maxCapacity * 0.5);
                            const max = Math.floor(maxCapacity * 0.85);
                            size = Math.floor(Math.random() * (max - min + 1)) + min;
                        } else { // 30% chance for a small item
                            const min = Math.floor(maxCapacity * 0.2);
                            const max = Math.floor(maxCapacity * 0.45);
                            size = Math.floor(Math.random() * (max - min + 1)) + min;
                        }
                        items.push({ 
                            id: `item-${i}`, 
                            size: Math.max(1, size), 
                            color: ITEM_COLORS[i % ITEM_COLORS.length] 
                        });
                    }
                    break;
            }
            
            return items;
        }

        function renderFullUI() {
            renderAvailableItems();
            renderBins();
            updateSolveButtonState();
            updateContainerTypeButtons();
            updateDifficultyButtons();
            updateInstanceStats();
        }

        function renderAvailableItems() {
            dom.itemsContainer.innerHTML = '';
            state.items.forEach(item => {
                if (!state.userAssignments.has(item.id)) {
                    const itemEl = createItemElement(item);
                    dom.itemsContainer.appendChild(itemEl);
                }
            });
        }

        function renderBins() {
            dom.binsContainer.innerHTML = '';
            for (let i = 0; i < state.binCapacities.length; i++) {
                dom.binsContainer.appendChild(createBinElement(i));
            }
            updateAllBinsVisuals();
        }

        function createItemElement(item) {
            const div = document.createElement('div');
            div.id = item.id;
            div.className = 'item-box bg-white rounded-lg p-2 text-center shadow-sm hover:shadow-md';
            div.draggable = true;
            div.innerHTML = `<div class="font-bold text-md">${item.size}</div>`;
            div.addEventListener('dragstart', e => handleItemDragStart(e, item, 'available'));
            return div;
        }

        function createBinElement(index) {
            const capacity = state.binCapacities[index];
            const div = document.createElement('div');
            div.id = `bin-${index}`;
            div.className = 'text-center';
            div.innerHTML = `
                <div class="bin-container-visual">
                    <div class="bin-items-wrapper"></div>
                </div>
                <div class="font-bold mt-2 text-sm">Contenedor ${index + 1}</div>
                <div class="text-xs text-slate-600"><span class="current-size">0</span> / ${capacity}</div>
            `;
            const glass = div.querySelector('.bin-container-visual');
            glass.addEventListener('dragover', e => { e.preventDefault(); glass.classList.add('drag-over'); });
            glass.addEventListener('dragleave', e => { glass.classList.remove('drag-over'); });
            glass.addEventListener('drop', e => handleDrop(e, `bin-${index}`));
            return div;
        }

        function handleItemDragStart(e, item, origin) {
            state.draggedItemId = item.id;
            state.draggedItemOrigin = origin;
        }

        function handleDropOnAvailable(e) {
            e.preventDefault();
            if (!state.draggedItemId || state.draggedItemOrigin === 'available') return;
            dom.itemsContainer.classList.remove('drag-over');
            state.userAssignments.delete(state.draggedItemId);
            state.currentAssignments = state.userAssignments;
            renderFullUI();
            updateAllBinsVisuals();
        }

        function handleDrop(e, binId) {
            e.preventDefault();
            if (!state.draggedItemId) return;

            const glassEl = e.currentTarget.querySelector('.bin-container-visual') || e.currentTarget;
            glassEl.classList.remove('drag-over');
            
            const item = state.items.find(i => i.id === state.draggedItemId);
            const binIndex = parseInt(binId.split('-')[1]);
            const capacity = state.binCapacities[binIndex];
            
            const assignmentsClone = new Map(state.userAssignments);
            if (state.draggedItemOrigin !== 'available') {
                 assignmentsClone.delete(item.id);
            }
            const currentSize = getBinSize(binId, assignmentsClone);

            if (currentSize + item.size <= capacity) {
                state.userAssignments.set(item.id, binId);
                state.currentAssignments = state.userAssignments;
                renderFullUI();
                updateAllBinsVisuals();
            } else {
                glassEl.classList.add('bin-full');
                setTimeout(() => glassEl.classList.remove('bin-full'), 300);
            }
            state.draggedItemId = null;
        }

        function getBinSize(binId, assignments) {
            let size = 0;
            for (const [itemId, assignedBinId] of assignments.entries()) {
                if (assignedBinId === binId) {
                    size += state.items.find(i => i.id === itemId).size;
                }
            }
            return size;
        }

        function updateAllBinsVisuals() {
            for (let i = 0; i < state.binCapacities.length; i++) {
                updateBinVisuals(`bin-${i}`);
            }
        }

        function updateBinVisuals(binId) {
            const binEl = document.getElementById(binId);
            if (!binEl) return;
            const itemsWrapper = binEl.querySelector('.bin-items-wrapper');
            const sizeEl = binEl.querySelector('.current-size');
            const binIndex = parseInt(binId.split('-')[1]);
            const capacity = state.binCapacities[binIndex];
            
            itemsWrapper.innerHTML = '';
            let currentSize = 0;

            for (const [itemId, assignedBinId] of state.currentAssignments.entries()) {
                if (assignedBinId === binId) {
                    const item = state.items.find(i => i.id === itemId);
                    currentSize += item.size;
                    const itemInBinEl = document.createElement('div');
                    itemInBinEl.id = item.id;
                    itemInBinEl.draggable = true;
                    itemInBinEl.className = 'item-in-bin';
                    itemInBinEl.style.height = `${(item.size / capacity) * 180}px`;
                    itemInBinEl.style.backgroundColor = item.color;
                    itemInBinEl.textContent = item.size;
                    itemInBinEl.addEventListener('dragstart', e => handleItemDragStart(e, item, binId));
                    itemsWrapper.appendChild(itemInBinEl);
                }
            }
            sizeEl.textContent = currentSize;
        }

        function updateSolveButtonState() {
            const allItemsPlaced = state.items.length > 0 && state.userAssignments.size === state.items.length;
            dom.solveButton.disabled = !allItemsPlaced;
        }

        function updateContainerTypeButtons() {
            const active = 'btn-type-active', inactive = 'btn-type-inactive';
            dom.typeHomoButton.className = `p-2 rounded-lg font-bold ${state.isHeterogeneous ? inactive : active}`;
            dom.typeHeteroButton.className = `p-2 rounded-lg font-bold ${state.isHeterogeneous ? active : inactive}`;
            dom.binCapacityLabel.textContent = state.isHeterogeneous ? "Capacidad Máxima:" : "Capacidad Base:";
        }

        function updateDifficultyButtons() {
            const active = 'btn-difficulty-active', inactive = 'btn-difficulty-inactive';
            dom.difficultyRandom.className = `p-2 rounded-lg font-bold ${state.difficultyStrategy === 'random' ? active : inactive}`;
            dom.difficultySmallItems.className = `p-2 rounded-lg font-bold ${state.difficultyStrategy === 'small-items' ? active : inactive}`;
            dom.difficultyLargeItems.className = `p-2 rounded-lg font-bold ${state.difficultyStrategy === 'large-items' ? active : inactive}`;
            dom.difficultyMixed.className = `p-2 rounded-lg font-bold ${state.difficultyStrategy === 'mixed' ? active : inactive}`;
            dom.difficultyTightFit.className = `p-2 rounded-lg font-bold ${state.difficultyStrategy === 'tight-fit' ? active : inactive}`;
        }

        function updateInstanceStats() {
            if (state.items.length === 0) return;
            
            const maxCapacity = parseInt(dom.binCapacityInput.value, 10);
            const totalItems = state.items.length;
            
            let smallCount = 0, mediumCount = 0, largeCount = 0;
            let totalSize = 0;
            
            state.items.forEach(item => {
                totalSize += item.size;
                const percentage = (item.size / maxCapacity) * 100;
                if (percentage <= 25) smallCount++;
                else if (percentage <= 75) mediumCount++;
                else largeCount++;
            });
            
            const avgUtilization = ((totalSize / (maxCapacity * totalItems)) * 100).toFixed(1);
            
            dom.totalItems.textContent = totalItems;
            dom.binCapacity.textContent = maxCapacity;
            dom.smallItems.textContent = `${smallCount} (${((smallCount/totalItems)*100).toFixed(0)}%)`;
            dom.mediumItems.textContent = `${mediumCount} (${((mediumCount/totalItems)*100).toFixed(0)}%)`;
            dom.largeItems.textContent = `${largeCount} (${((largeCount/totalItems)*100).toFixed(0)}%)`;
            dom.avgUtilization.textContent = `${avgUtilization}%`;
            
            // Explicación de por qué es difícil
            const explanations = {
                'random': 'Distribución aleatoria estándar. Dificultad moderada.',
                'small-items': 'Alta proporción de objetos pequeños (≤25% de capacidad). Requiere combinación precisa para llenar contenedores sin desperdicio. Muy difícil de optimizar.',
                'large-items': 'Mayoría de objetos grandes (>75% de capacidad). Difícil de combinar eficientemente, muchos contenedores se desperdician.',
                'mixed': 'Mezcla extrema de tamaños muy diferentes. Requiere estrategia sofisticada para combinar objetos pequeños y grandes eficientemente.',
                'tight-fit': 'Objetos diseñados para ajuste perfecto. Requiere encontrar la combinación exacta que maximice la utilización de cada contenedor.'
            };
            
            dom.difficultyExplanation.textContent = explanations[state.difficultyStrategy] || explanations['random'];
        }

        function solveHeuristicFFD() {
            const startTime = performance.now();
            const sortedItems = [...state.items].sort((a, b) => b.size - a.size);
            const bins = new Array(state.binCapacities.length).fill(0);
            const assignments = new Map();

            sortedItems.forEach(item => {
                for (let i = 0; i < state.binCapacities.length; i++) {
                    if (bins[i] + item.size <= state.binCapacities[i]) {
                        bins[i] += item.size;
                        assignments.set(item.id, `bin-${i}`);
                        break;
                    }
                }
            });
            const timeTaken = ((performance.now() - startTime) / 1000).toFixed(2);
            return { assignments, fitness: bins.filter(s => s > 0).length, timeTaken };
        }

        function runGeneticAlgorithm() {
            const startTime = performance.now();
            let population = generateValidInitialPopulation();
            let bestSolution = { chromosome: [], fitness: Infinity };

            for (let gen = 0; gen < GA_CONFIG.generations; gen++) {
                population.forEach((c, i) => population[i] = forceRepairChromosome(c));
                let evaluated = population.map(c => ({ chromosome: c, fitness: calculateFitness(c) }));
                let currentBest = evaluated.reduce((best, current) => (current.fitness < best.fitness) ? current : best, bestSolution);
                if (currentBest.fitness < bestSolution.fitness) bestSolution = currentBest;

                let newPopulation = [];
                if(bestSolution.fitness !== Infinity) newPopulation.push(bestSolution.chromosome);

                while (newPopulation.length < GA_CONFIG.populationSize) {
                    const p1 = tournamentSelection(evaluated).chromosome, p2 = tournamentSelection(evaluated).chromosome;
                    let [c1, c2] = crossover(p1, p2);
                    mutate(c1);
                    mutate(c2);
                    newPopulation.push(c1, c2);
                }
                population = newPopulation.slice(0, GA_CONFIG.populationSize);
            }
            
            const timeTaken = ((performance.now() - startTime) / 1000).toFixed(2);
            if (bestSolution.fitness !== Infinity) {
                const finalChromosome = normalizeChromosome(bestSolution.chromosome);
                const assignments = new Map();
                finalChromosome.forEach((binIndex, itemIndex) => {
                    assignments.set(state.items[itemIndex].id, `bin-${binIndex}`);
                });
                return { assignments, fitness: calculateFitness(finalChromosome), timeTaken };
            }
            return { assignments: new Map(), fitness: Infinity, timeTaken };
        }

        function generateValidInitialPopulation() {
            const population = [];
            const sortedItems = [...state.items].sort((a, b) => b.size - a.size);
            for (let i = 0; i < GA_CONFIG.populationSize; i++) {
                const chromosome = new Array(state.items.length).fill(-1);
                const bins = new Array(state.binCapacities.length).fill(0);
                const shuffledItems = [...sortedItems].sort(() => Math.random() - 0.5);
                shuffledItems.forEach(item => {
                    const originalIndex = state.items.findIndex(it => it.id === item.id);
                    const shuffledBins = [...Array(state.binCapacities.length).keys()].sort(() => Math.random() - 0.5);
                    for (const binIndex of shuffledBins) {
                        if (bins[binIndex] + item.size <= state.binCapacities[binIndex]) {
                            bins[binIndex] += item.size;
                            chromosome[originalIndex] = binIndex;
                            break;
                        }
                    }
                });
                population.push(chromosome);
            }
            return population;
        }

        function forceRepairChromosome(chromosome) {
            const bins = new Array(state.binCapacities.length).fill(0);
            const homelessItemIndices = [];
            for (let i = 0; i < chromosome.length; i++) {
                const binIndex = chromosome[i];
                if (binIndex === -1) {
                    homelessItemIndices.push(i);
                } else {
                    bins[binIndex] += state.items[i].size;
                }
            }
            for (let binIndex = 0; binIndex < bins.length; binIndex++) {
                if (bins[binIndex] > state.binCapacities[binIndex]) {
                    for (let itemIndex = 0; itemIndex < chromosome.length; itemIndex++) {
                        if (chromosome[itemIndex] === binIndex) {
                            homelessItemIndices.push(itemIndex);
                        }
                    }
                }
            }
            const uniqueHomelessIndices = [...new Set(homelessItemIndices)];
            if (uniqueHomelessIndices.length === 0) return chromosome;

            uniqueHomelessIndices.forEach(itemIndex => { chromosome[itemIndex] = -1; });
            
            const repairedBins = new Array(state.binCapacities.length).fill(0);
            for(let i=0; i<chromosome.length; i++) {
                if(chromosome[i] !== -1) repairedBins[chromosome[i]] += state.items[i].size;
            }

            uniqueHomelessIndices.sort((a,b) => state.items[b].size - state.items[a].size).forEach(itemIndex => {
                const item = state.items[itemIndex];
                let placed = false;
                for (let binIndex = 0; binIndex < state.binCapacities.length; binIndex++) {
                    if (repairedBins[binIndex] > 0 && repairedBins[binIndex] + item.size <= state.binCapacities[binIndex]) {
                        repairedBins[binIndex] += item.size;
                        chromosome[itemIndex] = binIndex;
                        placed = true;
                        break;
                    }
                }
                if (!placed) {
                    for (let binIndex = 0; binIndex < state.binCapacities.length; binIndex++) {
                        if (repairedBins[binIndex] === 0 && item.size <= state.binCapacities[binIndex]) {
                            repairedBins[binIndex] += item.size;
                            chromosome[itemIndex] = binIndex;
                            break;
                        }
                    }
                }
            });
            return chromosome;
        }

        function calculateFitness(chromosome) {
            const bins = new Array(state.binCapacities.length).fill(0);
            for (let i = 0; i < state.items.length; i++) {
                const binIndex = chromosome[i];
                if (binIndex === undefined || binIndex === -1) return Infinity;
                bins[binIndex] += state.items[i].size;
            }
            for (let i = 0; i < state.binCapacities.length; i++) {
                if (bins[i] > state.binCapacities[i]) return Infinity;
            }
            const binsUsed = bins.filter(size => size > 0).length;
            return binsUsed === 0 && state.items.length > 0 ? Infinity : binsUsed;
        }

        function tournamentSelection(evaluated) {
            const pool = evaluated.filter(s => s.fitness !== Infinity);
            if (pool.length === 0) return evaluated[Math.floor(Math.random() * evaluated.length)];
            let tournament = Array.from({ length: GA_CONFIG.tournamentSize }, () => pool[Math.floor(Math.random() * pool.length)]);
            return tournament.reduce((best, current) => (current.fitness < best.fitness) ? current : best);
        }

        function crossover(p1, p2) {
            if (Math.random() > GA_CONFIG.crossoverRate) return [[...p1], [...p2]];
            const point = Math.floor(Math.random() * (p1.length - 1)) + 1;
            return [p1.slice(0, point).concat(p2.slice(point)), p2.slice(0, point).concat(p1.slice(point))];
        }

        function mutate(chromosome) {
            for (let i = 0; i < chromosome.length; i++) {
                if (Math.random() < GA_CONFIG.mutationRate) {
                    chromosome[i] = Math.floor(Math.random() * state.items.length);
                }
            }
        }

        function normalizeChromosome(chromosome) {
            const mapping = {}; let nextBinIndex = 0;
            return chromosome.map(binIndex => {
                if (mapping[binIndex] === undefined) mapping[binIndex] = nextBinIndex++;
                return mapping[binIndex];
            });
        }

        function triggerSolve() {
            dom.solveButton.disabled = true;
            dom.resetButton.disabled = true;
            dom.loadingText.classList.remove('hidden');
            setTimeout(() => {
                const result = state.isHeterogeneous ? solveHeuristicFFD() : runGeneticAlgorithm();
                displayResults(result);
                dom.loadingText.classList.add('hidden');
            }, 50);
        }

        function displayResults(result) {
            dom.resetButton.disabled = false;
            const { assignments, fitness, timeTaken } = result;

            const userItemsPacked = state.userAssignments.size;
            const userBinsUsed = new Set(state.userAssignments.values()).size;
            dom.userBinsUsed.textContent = userBinsUsed;
            dom.userItemsPacked.textContent = `${userItemsPacked} / ${state.items.length}`;

            state.gaAssignments = assignments;
            const gaItemsPacked = state.gaAssignments.size;
            const gaBinsUsed = fitness === Infinity ? "Falló" : fitness;
            dom.gaBinsUsed.textContent = gaBinsUsed;
            dom.gaItemsPacked.textContent = `${gaItemsPacked} / ${state.items.length}`;
            dom.gaTime.textContent = `Calculado en ${timeTaken} segundos.`;

            const gaFailed = fitness === Infinity;

            if (gaFailed && !state.isHeterogeneous) { // Only show retry for GA
                dom.winnerMessage.innerHTML = 'El algoritmo no encontró una solución válida. ¡Inténtalo de nuevo! 🤖';
                dom.winnerMessage.className = 'text-center text-2xl font-bold my-4 p-4 rounded-lg bg-red-100 text-red-800';
                dom.retryGaButton.classList.remove('hidden');
                dom.comparisonControls.classList.add('hidden');
            } else {
                dom.retryGaButton.classList.add('hidden');
                dom.comparisonControls.classList.remove('hidden');
                if (gaFailed || userBinsUsed < gaBinsUsed) {
                    dom.winnerMessage.innerHTML = '🏆 ¡Felicidades, has ganado! 🏆';
                    dom.winnerMessage.className = 'text-center text-2xl font-bold my-4 p-4 rounded-lg bg-green-100 text-green-800';
                } else if (gaBinsUsed < userBinsUsed) {
                    dom.winnerMessage.innerHTML = '🤖 El Algoritmo ha ganado 🤖';
                    dom.winnerMessage.className = 'text-center text-2xl font-bold my-4 p-4 rounded-lg bg-teal-100 text-teal-800';
                } else {
                    dom.winnerMessage.innerHTML = '🤝 ¡Es un empate! 🤝';
                    dom.winnerMessage.className = 'text-center text-2xl font-bold my-4 p-4 rounded-lg bg-slate-100 text-slate-800';
                }
            }
            
            dom.comparisonControls.querySelector('#view-user-solution').onclick = () => {
                state.currentAssignments = state.userAssignments;
                renderBins();
            };
            dom.comparisonControls.querySelector('#view-ga-solution').onclick = () => {
                state.currentAssignments = state.gaAssignments;
                renderBins();
            };

            state.currentAssignments = state.gaAssignments;
            renderBins();

            dom.resultsModal.classList.remove('hidden');
            setTimeout(() => dom.modalContent.classList.remove('scale-95', 'opacity-0'), 10);
        }
        
        function initialize() {
            generateState();
            renderFullUI();
            dom.solveButton.disabled = true;
            dom.resetButton.disabled = false;
            dom.comparisonControls.classList.add('hidden');
            dom.resultsModal.classList.add('hidden');
            dom.modalContent.classList.add('scale-95', 'opacity-0');
            dom.retryGaButton.classList.add('hidden');
            
            dom.itemsContainer.addEventListener('dragover', e => { e.preventDefault(); dom.itemsContainer.classList.add('drag-over'); });
            dom.itemsContainer.addEventListener('dragleave', e => { dom.itemsContainer.classList.remove('drag-over'); });
            dom.itemsContainer.addEventListener('drop', handleDropOnAvailable);
        }

        dom.resetButton.addEventListener('click', initialize);
        dom.solveButton.addEventListener('click', triggerSolve);
        dom.retryGaButton.addEventListener('click', () => {
            dom.modalContent.classList.add('scale-95', 'opacity-0');
            setTimeout(() => {
                dom.resultsModal.classList.add('hidden');
                triggerSolve();
            }, 300);
        });
        dom.closeModalButton.addEventListener('click', () => {
             dom.modalContent.classList.add('scale-95', 'opacity-0');
                setTimeout(() => {
                    dom.resultsModal.classList.add('hidden');
                    dom.resetButton.disabled = false;
                }, 300);
        });
        dom.typeHomoButton.addEventListener('click', () => {
            if (state.isHeterogeneous === false) return;
            state.isHeterogeneous = false;
            initialize();
        });
        dom.typeHeteroButton.addEventListener('click', () => {
            if (state.isHeterogeneous === true) return;
            state.isHeterogeneous = true;
            initialize();
        });

        // Event listeners para botones de dificultad
        dom.difficultyRandom.addEventListener('click', () => {
            if (state.difficultyStrategy === 'random') return;
            state.difficultyStrategy = 'random';
            initialize();
        });
        dom.difficultySmallItems.addEventListener('click', () => {
            if (state.difficultyStrategy === 'small-items') return;
            state.difficultyStrategy = 'small-items';
            initialize();
        });
        dom.difficultyLargeItems.addEventListener('click', () => {
            if (state.difficultyStrategy === 'large-items') return;
            state.difficultyStrategy = 'large-items';
            initialize();
        });
        dom.difficultyMixed.addEventListener('click', () => {
            if (state.difficultyStrategy === 'mixed') return;
            state.difficultyStrategy = 'mixed';
            initialize();
        });
        dom.difficultyTightFit.addEventListener('click', () => {
            if (state.difficultyStrategy === 'tight-fit') return;
            state.difficultyStrategy = 'tight-fit';
            initialize();
        });

        // Event listener para el menú desplegable de instrucciones
        dom.toggleInstructions.addEventListener('click', () => {
            const content = dom.instructionsContent;
            const chevron = dom.instructionsChevron;
            
            if (content.classList.contains('hidden')) {
                content.classList.remove('hidden');
                chevron.style.transform = 'rotate(180deg)';
            } else {
                content.classList.add('hidden');
                chevron.style.transform = 'rotate(0deg)';
            }
        });

        initialize();
    });
    </script>
  <script>
    // --- LÓGICA DE PROTECCIÓN ---


    // 1. Deshabilitar el clic derecho en toda la página
    document.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        showProtectionToast('El clic derecho está deshabilitado.');
    });

    // 2. Bloquear atajos de teclado comunes
    document.addEventListener('keydown', function(e) {
        // Bloquear F12 para dificultar el acceso a las herramientas de desarrollador
        if (e.key === 'F12' || e.keyCode === 123) {
            e.preventDefault();
            showProtectionToast('Las herramientas de desarrollador están deshabilitadas.');
        }

        // Bloquear combinaciones con la tecla Ctrl
        if (e.ctrlKey) {
            const key = e.key.toLowerCase();
            if (['c', 'x', 'u', 's', 'p'].includes(key)) {
                e.preventDefault();
                showProtectionToast(`La función (Ctrl+${key.toUpperCase()}) ha sido deshabilitada.`);
            }
        }
    });
</script>

</body>
</html>