<!DOCTYPE html>
<html lang="es">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZLLCPFX9W7"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZLLCPFX9W7');
</script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>El problema del cartero chino</title>
    <link rel="icon" type="image/x-icon" href="../img/favicon.ico">

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            color: #1e293b;
        }
        .info-card {
            background-color: white;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.07), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        .node-circle-styling {
            fill: white;
            stroke: #0ea5e9;
            stroke-width: 3px;
            cursor: grab;
            transition: all 0.2s ease-in-out;
        }
        .node-circle-styling.odd-degree {
            stroke: #f59e0b; /* Naranja para grado impar */
            stroke-width: 4px;
        }
        .node-circle-styling.start-node {
            stroke: #10b981; /* Verde para nodo de inicio */
            stroke-width: 5px;
        }
        .node-circle-styling:active {
            cursor: grabbing;
        }
        .node-label {
            font-size: 14px;
            fill: #1e293b;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
        }
        .edge-line {
            stroke: #94a3b8;
            stroke-width: 3px;
            transition: all 0.3s;
        }
        #travelSVG {
            background-color: #f8fafc;
            background-image:
                linear-gradient(to right, #e2e8f0 1px, transparent 1px),
                linear-gradient(to bottom, #e2e8f0 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .edge-line.visited-by-user {
            stroke: #3b82f6;
        }
        .edge-line.visited-by-algo {
            stroke: #10b981;
        }
        .edge-line.duplicated {
            stroke: #f43f5e;
            stroke-dasharray: 5, 5;
            stroke-width: 4px;
        }
        .edge-hitbox {
            stroke: transparent;
            stroke-width: 15px;
            cursor: pointer;
        }
        .edge-weight {
            font-size: 12px;
            fill: #475569;
            font-weight: 500;
            text-anchor: middle;
            paint-order: stroke;
            stroke: #ffffff;
            stroke-width: 4px;
        }
        .path-marker {
            transition: all 0.5s ease-in-out;
        }
        /* Estilos del Modal */
        .modal-overlay {
            transition: opacity 0.3s ease-in-out;
        }
        .modal-content {
            transition: all 0.3s ease-in-out;
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">

    <div class="container mx-auto p-4 md:p-8 relative flex-grow">
    

            <div class="absolute top-4 right-4 flex items-center gap-4 z-10">

           <a href="../pasarela/buymeacoffee.html" 
               target="_blank" 
               rel="noopener noreferrer" 
               class="inline-flex items-center gap-2 bg-yellow-400 text-gray-900 font-bold py-2 px-4 rounded-lg shadow-sm transition-colors duration-300 hover:bg-yellow-500">
                
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M1 12.5a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13a.5.5 0 0 1-.5-.5M2 4v6h10V4zm11.5 0a.5.5 0 0 0-.5.5v5a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-5a.5.5 0 0 0-.5-.5zM1 3.5a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13a.5.5 0 0 1-.5-.5m10.854-1.354a.5.5 0 0 0-.708 0L9 3.293 7.854 2.146a.5.5 0 1 0-.708.708L8.293 4 7.146 5.146a.5.5 0 1 0 .708.708L9 4.707l1.146 1.147a.5.5 0 0 0 .708-.708L9.707 4l1.147-1.146a.5.5 0 0 0 0-.708"/>
                </svg>
                <span>Inv铆tame un caf茅</span>
            </a>

            <a href="../recursos/investigacion-operaciones.html" class="bg-white hover:bg-slate-100 text-slate-600 font-semibold py-2 px-4 border border-slate-200 rounded-lg shadow-sm flex items-center transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
                </svg>
                Inicio
            </a>
</div>
    
    
        <header class="text-center mb-8 pt-16">
            <h1 class="text-4xl md:text-5xl font-bold text-slate-800">Ayuda al cartero chino a recorrer las calles</h1>
            <p class="text-lg text-slate-500 mt-3">Encuentra el recorrido de menor costo que recorra todas las calles (aristas).</p>
        </header>

        <!-- Panel de Instrucciones y Explicaci贸n -->
        <div class="my-8 info-card p-6">
            <button id="toggleInstructions" class="w-full flex items-center justify-between text-2xl font-bold mb-4 text-indigo-600 hover:text-indigo-700 transition-colors">
                <span>驴C贸mo funciona?</span>
                <svg id="instructionsChevron" class="w-6 h-6 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
            <div id="instructionsContent" class="grid md:grid-cols-2 gap-6 text-slate-600">
                <div>
                    <h3 class="text-lg font-semibold mb-2">Instrucciones de uso</h3>
                    <ol class="list-decimal list-inside space-y-2">
                        <li><b>Arrastra los nodos</b> para organizar el grafo a tu gusto.</li>
                        <li>Haz clic en las <b>l铆neas (aristas)</b> para construir tu ruta, empezando desde tu posici贸n (marcador azul).</li>
                        <li>Tu objetivo es que todas las l铆neas se pongan azules (visitadas).</li>
                        <li><b>Debes regresar al nodo de inicio</b> (marcado con borde verde) para completar el circuito.</li>
                        <li>Si usas una arista m谩s de una vez, se marcar谩 con una <strong>l铆nea roja punteada</strong>.</li>
                        <li>Cuando termines, presiona <b>"Resolver"</b> para ver la soluci贸n 贸ptima y comparar resultados.</li>
                    </ol>
                </div>
                <div>
                    <h3 class="text-lg font-semibold mb-2">C谩lculo del recorrido</h3>
                    <p>
                        El costo total de un recorrido es la suma de los pesos de <b>todas las aristas</b> del mapa, m谩s un costo adicional por cada arista que deba ser recorrida m谩s de una vez. El algoritmo busca minimizar este costo extra, encontrando los "atajos" m谩s cortos para conectar los nodos "problem谩ticos" (aquellos con un n煤mero impar de conexiones).
                    </p>
                </div>
            </div>
        </div>


        <div class="w-full mx-auto">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                <main class="lg:col-span-2 bg-white rounded-2xl shadow-lg p-4 relative">
                    <svg id="travelSVG" class="w-full h-auto aspect-[4/3] rounded-lg"></svg>
                    <div id="loading" class="absolute inset-0 bg-white bg-opacity-80 flex-col items-center justify-center hidden rounded-lg">
                        <div class="animate-spin rounded-full h-16 w-16 border-b-4 border-indigo-600"></div>
                        <p class="mt-4 text-xl font-semibold text-slate-700">El algoritmo est谩 trabajando...</p>
                    </div>
                </main>

                <aside class="lg:col-span-1 flex flex-col gap-6">
                    <div class="info-card p-6">
                        <h2 class="text-xl font-bold border-b border-gray-200 pb-3 mb-4 text-indigo-600">Panel de control</h2>
                        <div class="space-y-4">
                            <div class="flex flex-col gap-2">
                                 <label for="node-slider" class="font-semibold text-slate-600">N煤mero de nodos: <span id="node-count-label">8</span></label>
                                 <input type="range" id="node-slider" min="6" max="16" value="8" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            </div>
                            <button id="resetBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 shadow-md hover:shadow-lg">Generar nuevo mapa</button>
                            <button id="runBtn" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 shadow-md hover:shadow-lg disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>Resolver</button>
                        </div>
                    </div>
                     <div class="info-card p-6">
                        <h2 class="text-xl font-bold border-b border-gray-200 pb-3 mb-4 text-indigo-600">Resultados</h2>
                        <div class="space-y-4">
                            <div><p class="font-semibold text-blue-600">Costo de tu ruta:</p><p id="userDistance" class="text-3xl font-mono font-bold text-slate-800">0</p></div>
                            <div><p class="font-semibold text-teal-600">Costo 贸ptimo del algoritmo:</p><p id="gaDistance" class="text-3xl font-mono font-bold text-slate-800">0</p></div>
                             <div><p class="font-semibold text-gray-500">Progreso:</p><p id="progress" class="text-xl font-mono font-bold text-slate-800">0 / 0</p></div>
                        </div>
                    </div>
                    <div class="info-card p-6">
                        <h2 class="text-xl font-bold border-b border-gray-200 pb-3 mb-4 text-indigo-600">Visualizaci贸n de recorridos</h2>
                        <div class="space-y-3">
                            <button id="playUserTourBtn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-slate-400 disabled:cursor-not-allowed" disabled>Animar mi recorrido</button>
                            <button id="playAlgoTourBtn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-slate-400 disabled:cursor-not-allowed" disabled>Animar recorrido 贸ptimo</button>
                        </div>
                    </div>
                </aside>
            </div>
        </div>
        
        <!-- Secci贸n de Detalle de Recorridos -->
        <div class="w-full mx-auto mt-8">
            <div class="info-card p-6">
                <h2 class="text-xl font-bold border-b border-gray-200 pb-3 mb-4 text-indigo-600">Detalle de recorridos</h2>
                <div class="grid md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-lg font-semibold text-blue-600 mb-2">Mi recorrido</h3>
                        <div id="userPathList" class="text-sm text-slate-600 max-h-32 overflow-y-auto bg-slate-50 p-3 rounded-lg">
                            <p class="text-slate-400 italic">Completa tu recorrido para ver la lista de aristas</p>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-lg font-semibold text-green-600 mb-2">Recorrido 贸ptimo</h3>
                        <div id="algoPathList" class="text-sm text-slate-600 max-h-32 overflow-y-auto bg-slate-50 p-3 rounded-lg">
                            <p class="text-slate-400 italic">Ejecuta el algoritmo para ver la lista de aristas</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Resultados -->
    <div id="results-modal" class="modal-overlay fixed inset-0 bg-slate-900 bg-opacity-50 flex items-center justify-center p-4 hidden opacity-0">
        <div id="modal-content" class="modal-content bg-white rounded-2xl shadow-2xl p-8 max-w-lg w-full transform scale-95">
            <h2 class="text-3xl font-bold text-center mb-4 text-slate-800">Resultados de la simulaci贸n</h2>
            <div id="winner-message" class="text-center text-2xl font-bold my-6 p-4 rounded-lg">
                <!-- Mensaje del ganador -->
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 text-center">
                <div class="bg-slate-100 p-6 rounded-lg">
                    <h3 class="text-xl font-bold mb-3 text-slate-700">Tu soluci贸n</h3>
                    <p class="text-3xl font-bold text-blue-600" id="modal-user-cost"></p>
                </div>
                <div class="bg-indigo-100 border-2 border-indigo-400 p-6 rounded-lg">
                    <h3 class="text-xl font-bold mb-3 text-slate-700">Soluci贸n 贸ptima</h3>
                    <p class="text-3xl font-bold text-teal-600" id="modal-ga-cost"></p>
                </div>
            </div>
            <div class="mt-8 text-center">
                <button id="close-modal-btn" class="bg-indigo-600 text-white font-bold py-2 px-8 rounded-lg hover:bg-indigo-700 transition-colors">Cerrar</button>
            </div>
        </div>
    </div>

    <!-- Modal de Finalizaci贸n -->
    <div id="completion-modal" class="modal-overlay fixed inset-0 bg-slate-900 bg-opacity-50 flex items-center justify-center p-4 hidden opacity-0">
        <div id="completion-modal-content" class="modal-content bg-white rounded-2xl shadow-2xl p-8 max-w-md w-full text-center transform scale-95">
            <h2 class="text-3xl font-bold text-center mb-4 text-slate-800">隆Felicidades!</h2>
            <p class="text-lg text-slate-600 mb-6">Has recorrido todas las calles. Ahora puedes comparar tu resultado con la soluci贸n 贸ptima.</p>
            <button id="close-completion-modal-btn" class="bg-indigo-600 text-white font-bold py-2 px-8 rounded-lg hover:bg-indigo-700 transition-colors">Entendido</button>
        </div>
    </div>



        <!-- Footer & Contact -->
    <footer id="contact" class="bg-[#333333] text-white">
        <div class="container mx-auto px-6 py-10">
            <div class="text-center">
             <!--   <h2 class="text-2xl font-bold mb-4">Ponte en Contacto</h2> -->
                <p class="text-gray-300 mb-2">Si tienes alguna pregunta o te gustar铆a colaborar, no dudes en escribirme.</p>
              <!--  <a href="mailto:jvelasco@cimat.mx" class="text-[#80CBC4] text-lg hover:underline">jvelasco@cimat.mx</a> -->
                <a href="../contacto.html" class="text-[#80CBC4] text-lg hover:underline">Contacto</a>
                <p class="text-gray-500 mt-8 text-sm">&copy; 2025 Jon谩s Velasco. Todos los derechos reservados.</p>
            </div>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.getElementById('travelSVG');
            const resetBtn = document.getElementById('resetBtn');
            const runBtn = document.getElementById('runBtn');
            const userDistanceEl = document.getElementById('userDistance');
            const optimalDistanceEl = document.getElementById('gaDistance');
            const loadingEl = document.getElementById('loading');
            const nodeSlider = document.getElementById('node-slider');
            const nodeCountLabel = document.getElementById('node-count-label');
            const progressEl = document.getElementById('progress');
            const playUserTourBtn = document.getElementById('playUserTourBtn');
            const playAlgoTourBtn = document.getElementById('playAlgoTourBtn');
            const completionModal = document.getElementById('completion-modal');
            const completionModalContent = document.getElementById('completion-modal-content');
            const closeCompletionModalBtn = document.getElementById('close-completion-modal-btn');
            const resultsModal = document.getElementById('results-modal');
            const modalContent = document.getElementById('modal-content');
            const winnerMessageEl = document.getElementById('winner-message');
            const modalUserCostEl = document.getElementById('modal-user-cost');
            const modalGaCostEl = document.getElementById('modal-ga-cost');
            const closeModalBtn = document.getElementById('close-modal-btn');
            
            let NUM_NODES = parseInt(nodeSlider.value, 10);
            const EXTRA_EDGE_PROBABILITY = 0.2;

            let nodes = [], edges = [], adjacency = {}, startNode = 0;
            let userPath = [], visitedEdges = new Set(), optimalTour = [];
            let selectedNode = null, offset = { x: 0, y: 0 };
            let totalEdgeCount = 0;

            // Variables globales para el SVG
            let svgWidth = 800;
            let svgHeight = 600;
            let animationState = null;
            let currentNode = startNode;
            let userEdgeCounts = new Map();

            // Funciones auxiliares
            function showMessage(message, type) {
                // Crear elemento de mensaje
                const messageDiv = document.createElement('div');
                messageDiv.className = `fixed top-4 right-4 p-4 rounded-lg shadow-lg z-50 max-w-md transition-all duration-300 ${
                    type === 'success' ? 'bg-green-100 text-green-800 border border-green-200' :
                    type === 'info' ? 'bg-blue-100 text-blue-800 border border-blue-200' :
                    'bg-gray-100 text-gray-800 border border-gray-200'
                }`;
                messageDiv.innerHTML = `
                    <div class="flex items-start">
                        <div class="flex-1">
                            <p class="font-medium">${message}</p>
                        </div>
                        <button class="ml-2 text-gray-400 hover:text-gray-600" onclick="this.parentElement.parentElement.remove()">
                            <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                            </svg>
                        </button>
                    </div>
                `;
                
                document.body.appendChild(messageDiv);
                
                // Auto-remover despu茅s de 5 segundos
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.remove();
                    }
                }, 5000);
            }
            
            function draw(state = {}) {
                svg.innerHTML = '';
                const { oddNodes = [], duplicatedEdges = [], animationState = null } = state;
                const nodeRadius = Math.max(10, 20 - NUM_NODES / 4);
                
                const edgesGroup = document.createElementNS(svgNS, 'g');
                const nodesGroup = document.createElementNS(svgNS, 'g');
                
                const lastUserNode = userPath.length > 0 ? userPath[userPath.length - 1].to : startNode;

                const userEdgeCounts = new Map();
                userPath.forEach(edge => {
                    const id = `${Math.min(edge.from, edge.to)}-${Math.max(edge.from, edge.to)}`;
                    userEdgeCounts.set(id, (userEdgeCounts.get(id) || 0) + 1);
                });

                edges.forEach((edge, index) => {
                    const n1 = nodes[edge.from], n2 = nodes[edge.to];
                    const dx = n2.x - n1.x, dy = n2.y - n1.y;
                    const edgeId = `${Math.min(edge.from, edge.to)}-${Math.max(edge.from, edge.to)}`;

                    const line = document.createElementNS(svgNS, 'line');
                    line.setAttribute('x1', n1.x); line.setAttribute('y1', n1.y);
                    line.setAttribute('x2', n2.x); line.setAttribute('y2', n2.y);
                    line.setAttribute('class', 'edge-line');
                    
                    // Mostrar aristas visitadas durante animaci贸n o mientras el usuario juega
                    if (animationState) {
                        const visitedInAnim = animationState.visited.has(edge.id) || animationState.visited.has(`${edge.to}-${edge.from}`);
                        if(visitedInAnim) line.classList.add(animationState.type === 'user' ? 'visited-by-user' : 'visited-by-algo');
                    } else if (visitedEdges.has(edgeId) && (userPath.length > 0 && visitedEdges.size <= totalEdgeCount)) {
                        line.classList.add('visited-by-user');
                    }

                    const weightText = document.createElementNS(svgNS, 'text');
                    weightText.setAttribute('x', n1.x + dx * 0.5); weightText.setAttribute('y', n1.y + dy * 0.5);
                    weightText.setAttribute('class', 'edge-weight');
                    weightText.textContent = edge.weight;

                    const hitbox = document.createElementNS(svgNS, 'line');
                    hitbox.setAttribute('x1', n1.x); hitbox.setAttribute('y1', n1.y);
                    hitbox.setAttribute('x2', n2.x); hitbox.setAttribute('y2', n2.y);
                    hitbox.setAttribute('class', 'edge-hitbox');
                    hitbox.dataset.edgeIndex = index;
                    
                    edgesGroup.appendChild(line);
                    edgesGroup.appendChild(weightText);
                    edgesGroup.appendChild(hitbox);

                    // Mostrar aristas duplicadas del usuario durante animaci贸n o mientras juega
                    if ((userEdgeCounts.get(edgeId) || 0) > 1 && (animationState || (userPath.length > 0 && visitedEdges.size <= totalEdgeCount))) {
                         const dupLine = document.createElementNS(svgNS, 'line');
                         dupLine.setAttribute('x1', n1.x + 3); dupLine.setAttribute('y1', n1.y + 3);
                         dupLine.setAttribute('x2', n2.x + 3); dupLine.setAttribute('y2', n2.y + 3);
                         dupLine.setAttribute('class', 'edge-line duplicated');
                         edgesGroup.appendChild(dupLine);
                    }
                });
                
                // Mostrar aristas duplicadas seg煤n el estado
                if (animationState) {
                    // Durante animaci贸n: solo mostrar las que van apareciendo din谩micamente
                    if (animationState.duplicatedEdges) {
                        animationState.duplicatedEdges.forEach(edge => {
                             const n1 = nodes[edge.from], n2 = nodes[edge.to];
                             const line = document.createElementNS(svgNS, 'line');
                             line.setAttribute('x1', n1.x + 3); line.setAttribute('y1', n1.y + 3);
                             line.setAttribute('x2', n2.x + 3); line.setAttribute('y2', n2.y + 3);
                             line.setAttribute('class', 'edge-line duplicated');
                             edgesGroup.appendChild(line);
                        });
                    }
                    // No mostrar duplicadas est谩ticas durante animaci贸n si hideStaticDuplicates est谩 activo
                }
                // No mostrar duplicadas est谩ticas cuando no hay animaci贸n

                nodes.forEach(node => {
                    const circle = document.createElementNS(svgNS, 'circle');
                    circle.setAttribute('cx', node.x); circle.setAttribute('cy', node.y);
                    circle.setAttribute('r', nodeRadius);
                    circle.setAttribute('data-id', node.id);
                    circle.setAttribute('class', 'node-circle-styling');
                    if (oddNodes.includes(node.id)) {
                        circle.classList.add('odd-degree');
                    }
                    if (node.id === startNode) {
                        circle.classList.add('start-node');
                    }
                    
                    const text = document.createElementNS(svgNS, 'text');
                    text.setAttribute('x', node.x); text.setAttribute('y', node.y);
                    text.setAttribute('class', 'node-label');
                    text.style.fontSize = `${Math.max(10, 15 - NUM_NODES / 5)}px`;
                    text.textContent = node.id + 1;
                    nodesGroup.appendChild(circle);
                    nodesGroup.appendChild(text);
                });

                // Solo mostrar marcador durante animaci贸n o cuando el usuario est谩 jugando
                if (animationState || (userPath.length > 0 && visitedEdges.size < totalEdgeCount)) {
                    const marker = document.createElementNS(svgNS, 'circle');
                    marker.setAttribute('r', nodeRadius / 2);
                    marker.setAttribute('class', 'path-marker');
                    marker.style.fill = animationState ? (animationState.type === 'user' ? '#3b82f6' : '#10b981') : '#3b82f6';
                    const markerNode = animationState ? nodes[animationState.currentNode] : nodes[lastUserNode];
                    marker.setAttribute('cx', markerNode.x);
                    marker.setAttribute('cy', markerNode.y);
                    nodesGroup.appendChild(marker);
                }
                
                svg.appendChild(edgesGroup); svg.appendChild(nodesGroup);
            }
            
            function dijkstra(startNodeId) {
                const distances = {};
                const prev = {};
                const pq = new Set();

                nodes.forEach(node => {
                    distances[node.id] = Infinity;
                    prev[node.id] = null;
                    pq.add(node.id);
                });
                distances[startNodeId] = 0;

                while (pq.size > 0) {
                    let u = Array.from(pq).reduce((minNode, currentNode) => distances[currentNode] < distances[minNode] ? currentNode : minNode, Array.from(pq)[0]);
                    pq.delete(u);

                    if (adjacency[u]) {
                        adjacency[u].forEach(neighbor => {
                            if (pq.has(neighbor.node)) {
                                const alt = distances[u] + neighbor.weight;
                                if (alt < distances[neighbor.node]) {
                                    distances[neighbor.node] = alt;
                                    prev[neighbor.node] = u;
                                }
                            }
                        });
                    }
                }
                return { distances, prev };
            }

            function reconstructPath(dijkstraResult, start, end) {
                const path = [];
                let current = end;
                while (current !== null) {
                    path.unshift(current);
                    if (current === start) break;
                    current = dijkstraResult.prev[current];
                }
                return path;
            }

            function getMinWeightPerfectMatching(oddNodes, allPaths) {
                if (oddNodes.length === 0) return [];
                if (oddNodes.length === 2) return [[oddNodes[0], oddNodes[1]]];
                
                // Generar todas las posibles particiones en pares
                function generateAllPairings(nodes) {
                    if (nodes.length === 0) return [[]];
                    if (nodes.length === 2) return [[[nodes[0], nodes[1]]]];
                    
                    const first = nodes[0];
                    const allPairings = [];
                    
                    for (let i = 1; i < nodes.length; i++) {
                        const partner = nodes[i];
                        const remaining = nodes.slice(1, i).concat(nodes.slice(i + 1));
                        const subPairings = generateAllPairings(remaining);
                        
                        subPairings.forEach(subPairing => {
                            allPairings.push([[first, partner], ...subPairing]);
                        });
                    }
                    return allPairings;
                }
                
                const allPossiblePairings = generateAllPairings(oddNodes);
                let bestPairing = [];
                let minWeight = Infinity;
                
                allPossiblePairings.forEach(pairing => {
                    const weight = pairing.reduce((sum, pair) => {
                        return sum + allPaths[pair[0]].distances[pair[1]];
                    }, 0);
                    
                    if (weight < minWeight) {
                        minWeight = weight;
                        bestPairing = pairing;
                    }
                });
                
                return bestPairing;
            }
            
            function updateUserPathList() {
                const userPathListEl = document.getElementById('userPathList');
                if (userPath.length === 0) {
                    userPathListEl.innerHTML = '<p class="text-slate-400 italic">Completa tu recorrido para ver la lista de aristas</p>';
                    return;
                }
                
                const pathText = userPath.map(edge => `(${edge.from + 1}, ${edge.to + 1})`).join(', ');
                userPathListEl.innerHTML = `<p><strong>Aristas:</strong> ${pathText}</p><p><strong>Total:</strong> ${userPath.length} aristas</p>`;
            }

            function updateAlgoPathList() {
                const algoPathListEl = document.getElementById('algoPathList');
                if (!optimalTour || optimalTour.length === 0) {
                    algoPathListEl.innerHTML = '<p class="text-slate-400 italic">Ejecuta el algoritmo para ver la lista de aristas</p>';
                    return;
                }
                
                const pathText = optimalTour.map(edge => `(${edge.from + 1}, ${edge.to + 1})`).join(', ');
                algoPathListEl.innerHTML = `<p><strong>Aristas:</strong> ${pathText}</p><p><strong>Total:</strong> ${optimalTour.length} aristas</p>`;
            }

            async function solveCPP(){
                loadingEl.style.display="flex";
                runBtn.disabled = true;
                
                const oddNodes=nodes.filter(e=>adjacency[e.id].length%2!=0).map(e=>e.id);
                draw({oddNodes:oddNodes});
                await new Promise(e=>setTimeout(e,500));

                if(0===oddNodes.length){
                    const totalWeight = edges.reduce((sum, edge) => sum + edge.weight, 0);
                    optimalDistanceEl.textContent = totalWeight;
                    optimalTour = nodePathToEdgePath(findEulerianTour(adjacency, startNode));
                    document.getElementById('playAlgoTourBtn').disabled = false;
                    
                    // Actualizar la lista de aristas del algoritmo
                    updateAlgoPathList();
                    
                    loadingEl.style.display="none";
                    runBtn.disabled = false;
                } else {
                    const allPaths={};
                    for(const node of oddNodes) allPaths[node]=dijkstra(node);

                    const pairings=getMinWeightPerfectMatching(oddNodes,allPaths);
                    
                    let duplicatedCost=0;
                    const duplicatedEdges=[];
                    for(const pair of pairings){
                        let path=reconstructPath(allPaths[pair[0]],pair[0],pair[1]);
                        duplicatedCost+=allPaths[pair[0]].distances[pair[1]];
                        for(let i=0;i<path.length-1;i++) duplicatedEdges.push({from:path[i],to:path[i+1]});
                    }
                    draw({oddNodes:oddNodes,duplicatedEdges:duplicatedEdges});
                    await new Promise(e=>setTimeout(e,500));

                    const augmentedAdj=JSON.parse(JSON.stringify(adjacency));
                    duplicatedEdges.forEach(e=>{
                        const edgeData=adjacency[e.from].find(adjEdge=>adjEdge.node===e.to);
                        if(edgeData){
                            augmentedAdj[e.from].push({node:e.to,weight:edgeData.weight});
                            augmentedAdj[e.to].push({node:e.from,weight:edgeData.weight});
                        }
                    });

                    const eulerianNodePath=findEulerianTour(augmentedAdj,startNode);
                    optimalTour=nodePathToEdgePath(eulerianNodePath);
                    
                    const totalCost = edges.reduce((sum, edge) => sum + edge.weight, 0) + duplicatedCost;
                    optimalDistanceEl.textContent = totalCost;
                    document.getElementById('playAlgoTourBtn').disabled = false;
                    
                    // Actualizar la lista de aristas del algoritmo
                    updateAlgoPathList();
                    
                    loadingEl.style.display="none";
                    runBtn.disabled = false;
                }
            }

            function findEulerianTour(adj, start) {
                const tempAdj = JSON.parse(JSON.stringify(adj));
                let currPath = [start];
                let tour = [];

                while (currPath.length > 0) {
                    let u = currPath[currPath.length-1];
                    if (tempAdj[u] && tempAdj[u].length > 0) {
                        let v = tempAdj[u].pop().node;
                        const vIndex = tempAdj[v] ? tempAdj[v].findIndex(edge => edge.node === u) : -1;
                        if (vIndex > -1) tempAdj[v].splice(vIndex, 1);
                        currPath.push(v);
                    } else {
                        tour.push(currPath.pop());
                    }
                }
                return tour.reverse();
            }

            function nodePathToEdgePath(nodePath) {
                const edgePath = [];
                for (let i = 0; i < nodePath.length - 1; i++) {
                    const u = nodePath[i];
                    const v = nodePath[i+1];
                    const edge = edges.find(e => (e.from === u && e.to === v));
                    if (edge) {
                        edgePath.push({from: u, to: v, weight: edge.weight, id: edge.id});
                    } else {
                        const reverseEdge = edges.find(e => (e.from === v && e.to === u));
                        if (reverseEdge) {
                             edgePath.push({from: u, to: v, weight: reverseEdge.weight, id: reverseEdge.id});
                        }
                    }
                }
                return edgePath;
            }

            async function animatePath(path, type) {
                playUserTourBtn.disabled = true;
                playAlgoTourBtn.disabled = true;
                let visitedInAnim = new Set();
                let edgeUsageCount = new Map();
                let duplicatedInAnim = [];
                
                // Iniciar animaci贸n sin aristas duplicadas visibles
                draw({ 
                    animationState: { 
                        type, 
                        visited: new Set(), 
                        currentNode: path.length > 0 ? path[0].from : startNode,
                        duplicatedEdges: [],
                        hideStaticDuplicates: true
                    } 
                });
                await new Promise(r => setTimeout(r, 300));
                
                for (let i = 0; i < path.length; i++) {
                    const edge = path[i];
                    const edgeId = `${Math.min(edge.from, edge.to)}-${Math.max(edge.from, edge.to)}`;
                    visitedInAnim.add(edgeId);
                    
                    // Contar el uso de cada arista
                    const currentCount = edgeUsageCount.get(edgeId) || 0;
                    edgeUsageCount.set(edgeId, currentCount + 1);
                    
                    // Si es la segunda vez que se usa esta arista, agregarla a duplicadas
                    if (currentCount === 1) {
                        duplicatedInAnim.push({from: edge.from, to: edge.to});
                    }
                    
                    draw({ 
                        animationState: { 
                            type, 
                            visited: visitedInAnim, 
                            currentNode: edge.to,
                            duplicatedEdges: type === 'algo' ? duplicatedInAnim : (type === 'user' ? duplicatedInAnim : []),
                            hideStaticDuplicates: true
                        } 
                    });
                    await new Promise(r => setTimeout(r, 500));
                }
                
                // Al terminar la animaci贸n, restaurar vista normal
                draw();
                
                if (userPath.length > 0 && visitedEdges.size === totalEdgeCount) playUserTourBtn.disabled = false;
                if (optimalTour.length > 0) playAlgoTourBtn.disabled = false;
            }
            
            function handleReset() {
                visitedEdges.clear();
                userPath = [];
                optimalTour = [];
                animationState = null;
                currentNode = startNode;
                
                // Generar grafo aleatorio usando el valor del slider
                const nodeCount = parseInt(nodeSlider.value, 10);
                nodes = [];
                edges = [];
                adjacency = {};
                
                // Crear nodos en posiciones aleatorias
                for (let i = 0; i < nodeCount; i++) {
                    nodes.push({
                        id: i,
                        x: Math.random() * (svgWidth - 100) + 50,
                        y: Math.random() * (svgHeight - 100) + 50
                    });
                    adjacency[i] = [];
                }
                
                // Crear aristas para garantizar conectividad (谩rbol de expansi贸n m铆nimo)
                const connected = new Set([0]);
                const unconnected = new Set(nodes.slice(1).map(n => n.id));
                
                while (unconnected.size > 0) {
                    const connectedNode = Array.from(connected)[Math.floor(Math.random() * connected.size)];
                    const unconnectedNode = Array.from(unconnected)[Math.floor(Math.random() * unconnected.size)];
                    
                    const weight = Math.floor(Math.random() * 90) + 10;
                    const edgeId = `${Math.min(connectedNode, unconnectedNode)}-${Math.max(connectedNode, unconnectedNode)}`;
                    
                    edges.push({
                        id: edgeId,
                        from: connectedNode,
                        to: unconnectedNode,
                        weight: weight
                    });
                    
                    adjacency[connectedNode].push({node: unconnectedNode, weight: weight});
                    adjacency[unconnectedNode].push({node: connectedNode, weight: weight});
                    
                    connected.add(unconnectedNode);
                    unconnected.delete(unconnectedNode);
                }
                
                // A帽adir aristas adicionales aleatorias, asegurando que no haya nodos de grado 1
                const additionalEdges = Math.floor(Math.random() * (nodeCount - 1)) + 1;
                for (let i = 0; i < additionalEdges; i++) {
                    let from, to;
                    let attempts = 0;
                    do {
                        from = Math.floor(Math.random() * nodeCount);
                        to = Math.floor(Math.random() * nodeCount);
                        attempts++;
                    } while ((from === to || adjacency[from].some(adj => adj.node === to)) && attempts < 50);
                    
                    if (attempts < 50) {
                        const weight = Math.floor(Math.random() * 90) + 10;
                        const edgeId = `${Math.min(from, to)}-${Math.max(from, to)}`;
                        
                        edges.push({
                            id: edgeId,
                            from: from,
                            to: to,
                            weight: weight
                        });
                        
                        adjacency[from].push({node: to, weight: weight});
                        adjacency[to].push({node: from, weight: weight});
                    }
                }
                
                // Verificar y corregir nodos de grado 1
                let hasChanges = true;
                while (hasChanges) {
                    hasChanges = false;
                    for (let nodeId = 0; nodeId < nodeCount; nodeId++) {
                        if (adjacency[nodeId].length === 1) {
                            // Encontrar otro nodo para conectar (preferiblemente que no sea el 煤nico vecino)
                            let targetNode = -1;
                            for (let candidate = 0; candidate < nodeCount; candidate++) {
                                if (candidate !== nodeId && 
                                    !adjacency[nodeId].some(adj => adj.node === candidate) &&
                                    adjacency[candidate].length > 1) {
                                    targetNode = candidate;
                                    break;
                                }
                            }
                            
                            // Si no encontramos un nodo con grado > 1, usar cualquier nodo disponible
                            if (targetNode === -1) {
                                for (let candidate = 0; candidate < nodeCount; candidate++) {
                                    if (candidate !== nodeId && 
                                        !adjacency[nodeId].some(adj => adj.node === candidate)) {
                                        targetNode = candidate;
                                        break;
                                    }
                                }
                            }
                            
                            if (targetNode !== -1) {
                                const weight = Math.floor(Math.random() * 90) + 10;
                                const edgeId = `${Math.min(nodeId, targetNode)}-${Math.max(nodeId, targetNode)}`;
                                
                                edges.push({
                                    id: edgeId,
                                    from: nodeId,
                                    to: targetNode,
                                    weight: weight
                                });
                                
                                adjacency[nodeId].push({node: targetNode, weight: weight});
                                adjacency[targetNode].push({node: nodeId, weight: weight});
                                hasChanges = true;
                            }
                        }
                    }
                }
                
                totalEdgeCount = edges.length;
                userDistanceEl.textContent = '0';
                optimalDistanceEl.textContent = '0';
                document.getElementById('progress').textContent = `0 / ${totalEdgeCount}`;
                
                // Deshabilitar botones
                document.getElementById('runBtn').disabled = true;
                document.getElementById('playUserTourBtn').disabled = true;
                document.getElementById('playAlgoTourBtn').disabled = true;
                
                // Limpiar listas de recorridos
                updateUserPathList();
                updateAlgoPathList();
                
                draw();
            }
            
            function displayResults() {
                const userCost = parseInt(userDistanceEl.textContent);
                const algoCost = parseInt(optimalDistanceEl.textContent);

                modalUserCostEl.textContent = userCost;
                modalGaCostEl.textContent = algoCost;

                if (userCost < algoCost) {
                    winnerMessageEl.innerHTML = ' 隆Felicidades, has ganado! ';
                    winnerMessageEl.className = 'text-center text-2xl font-bold my-6 p-4 rounded-lg bg-green-100 text-green-800';
                } else if (algoCost < userCost) {
                    winnerMessageEl.innerHTML = ' El algoritmo ha ganado ';
                    winnerMessageEl.className = 'text-center text-2xl font-bold my-6 p-4 rounded-lg bg-indigo-100 text-indigo-800';
                } else {
                    winnerMessageEl.innerHTML = ' 隆Es un empate! ';
                    winnerMessageEl.className = 'text-center text-2xl font-bold my-6 p-4 rounded-lg bg-slate-100 text-slate-800';
                }

                resultsModal.classList.remove('hidden');
                setTimeout(() => {
                    resultsModal.classList.remove('opacity-0');
                    modalContent.classList.remove('scale-95');
                }, 10);
            }

            resetBtn.addEventListener('click', handleReset);
            nodeSlider.addEventListener('input', (e) => { nodeCountLabel.textContent = e.target.value; });
            nodeSlider.addEventListener('change', handleReset);
            runBtn.addEventListener('click', solveCPP);
            playUserTourBtn.addEventListener('click', () => animatePath(userPath, 'user'));
            playAlgoTourBtn.addEventListener('click', () => animatePath(optimalTour, 'algo'));
            
            svg.addEventListener('click', (e) => {
                const edgeIndex = e.target.dataset.edgeIndex;
                if (edgeIndex === undefined) return;

                const clickedEdge = edges[parseInt(edgeIndex, 10)];
                const currentNode = userPath.length > 0 ? userPath[userPath.length - 1].to : startNode;

                if (clickedEdge.from === currentNode || clickedEdge.to === currentNode) {
                    const nextNode = clickedEdge.from === currentNode ? clickedEdge.to : clickedEdge.from;
                    const edgeToAdd = {from: currentNode, to: nextNode, weight: clickedEdge.weight, id: `${Math.min(currentNode, nextNode)}-${Math.max(currentNode, nextNode)}`};
                    
                    userPath.push(edgeToAdd);
                    visitedEdges.add(edgeToAdd.id);

                    userDistanceEl.textContent = userPath.reduce((sum, edge) => sum + edge.weight, 0);
                    document.getElementById('progress').textContent = `${visitedEdges.size} / ${totalEdgeCount}`;
                
                    // Actualizar la lista de aristas del usuario
                    updateUserPathList();
                
                    // Verificar si el usuario ha completado el recorrido
                    if (visitedEdges.size === totalEdgeCount && nextNode === startNode) {
                        document.getElementById('runBtn').disabled = false;
                        document.getElementById('playUserTourBtn').disabled = false;
                        showMessage('隆Felicidades! Has completado el recorrido. Ahora puedes resolver el algoritmo para comparar.', 'success');
                    } else if (visitedEdges.size === totalEdgeCount) {
                        showMessage('隆Has visitado todas las aristas! Ahora debes regresar al nodo de inicio (verde) para completar el circuito.', 'info');
                        // Mostrar mensaje indicando que debe regresar al inicio
                        progressEl.textContent = `${visitedEdges.size} / ${totalEdgeCount} - Regresa al nodo ${startNode + 1}`;
                    }
                    draw();
                }
            });

            closeCompletionModalBtn.addEventListener('click', () => {
                completionModal.classList.add('opacity-0');
                completionModalContent.classList.add('scale-95');
                setTimeout(() => {
                    completionModal.classList.add('hidden');
                }, 300);
            });

            closeModalBtn.addEventListener('click', () => {
                resultsModal.classList.add('opacity-0');
                modalContent.classList.add('scale-95');
                setTimeout(() => {
                    resultsModal.classList.add('hidden');
                }, 300);
            });

            svg.addEventListener('mousedown', (e) => {
                if (e.target.tagName === 'circle') {
                    selectedNode = nodes.find(n => n.id === parseInt(e.target.dataset.id));
                    const CTM = svg.getScreenCTM();
                    if (selectedNode && CTM) {
                        offset.x = (e.clientX - CTM.e) / CTM.a - selectedNode.x;
                        offset.y = (e.clientY - CTM.f) / CTM.d - selectedNode.y;
                    }
                }
            });
            svg.addEventListener('mousemove', (e) => {
                if (selectedNode) {
                    const CTM = svg.getScreenCTM();
                    if (CTM) {
                        selectedNode.x = (e.clientX - CTM.e) / CTM.a - offset.x;
                        selectedNode.y = (e.clientY - CTM.f) / CTM.d - offset.y;
                        draw();
                    }
                }
            });
            svg.addEventListener('mouseup', () => { selectedNode = null; });
            svg.addEventListener('mouseleave', () => { selectedNode = null; });

            // Toggle instructions functionality
            const toggleInstructionsBtn = document.getElementById('toggleInstructions');
            const instructionsContent = document.getElementById('instructionsContent');
            const instructionsChevron = document.getElementById('instructionsChevron');
            
            // Initialize as collapsed
            instructionsContent.style.display = 'none';
            instructionsChevron.style.transform = 'rotate(-90deg)';
            
            toggleInstructionsBtn.addEventListener('click', () => {
                const isHidden = instructionsContent.style.display === 'none';
                instructionsContent.style.display = isHidden ? 'grid' : 'none';
                instructionsChevron.style.transform = isHidden ? 'rotate(0deg)' : 'rotate(-90deg)';
            });

            window.addEventListener('resize', () => { if(nodes.length > 0) { handleReset() } });
            
            handleReset();
        });
    </script>

    <script>
        // --- LGICA DE PROTECCIN ---


        // 1. Deshabilitar el clic derecho en toda la p谩gina
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            showProtectionToast('El clic derecho est谩 deshabilitado.');
        });

        // 2. Bloquear atajos de teclado comunes
        document.addEventListener('keydown', function(e) {
            // Bloquear F12 para dificultar el acceso a las herramientas de desarrollador
            if (e.key === 'F12' || e.keyCode === 123) {
                e.preventDefault();
                showProtectionToast('Las herramientas de desarrollador est谩n deshabilitadas.');
            }

            // Bloquear combinaciones con la tecla Ctrl
            if (e.ctrlKey) {
                const key = e.key.toLowerCase();
                if (['c', 'x', 'u', 's', 'p'].includes(key)) {
                    e.preventDefault();
                    showProtectionToast(`La funci贸n (Ctrl+${key.toUpperCase()}) ha sido deshabilitada.`);
                }
            }
        });
    </script>  


<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZLLCPFX9W7"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZLLCPFX9W7');
</script>

</body>
</html>

